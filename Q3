import sys
import random

class Node:
  def __init__(self, data):
    self.data = data
    self.isvisited = False

class Graph:
  def addNode(self, d, el):
    n = Node(el)
    d[n] = ''

  def addUndirectedEdge(self, d, first, second):
    if first!=None and second!=None:
      d[first].append(second)
      d[second].append(first)
  
  def removeUndirectedEdge(self, d, first, second):
    if first!=None and second!=None and first in d[second] and second in d[first]:
      d[first].pop(second)
      d[second].pop(first)

  def getAllNodes(self, d):
    k = d.keys()
    return k

class Main:
  def createRandomUnweightedGraphIter(d, n):
    graph = Graph()
    rando_edges = []
    node_edges = []
    if n==0:
      return graph
    else:
      for i in range(n):
        graph.addNode(i)
        if n==1:
          return graph
        else:
          rando_edges.append(random.randint(0,n))
          for x in range(rando_edges[i]):
            neighbor = (random.randint(0,n))
            node_edges.append((i, neighbor))
    for element in node_edges:
      if element[0] in d and element[1] in d:
        graph.addUndirectedEdge(d, element[0], element[1])
    return graph

  def createLinkedList(d, n):
    graph = Graph()
    curr = 0
    nxt = 0
    for i in range(n):
      cur = i
      nxt = i + 1
      graph.addUndirectedEdge(d, cur, nxt)
    return graph
  
  #I'm confused for these two parts
  #Do we just pass the methods, assuming the graphs are linked lists?
  def BFTRecLinkedList(graph):
    recll = GraphSearch.BFTRec(graph)
    return recll

  def BFTIterLinkedList(graph):
    iterll = GraphSearch.BFTIter(graph)
    return iterll


class GraphSearch:
  def DFSRec(d, start, end):
    searched = []
    if start.data == end.data:
      start.isvisited = True
      searched.append(start)
      return searched
    else:
      start.isvisited = True
      searched.append(start)
      if start in d:
        nxt = d[start]
        recurs = GraphSearch.DFSRec(d, nxt, end)
        if recurs:
          return recurs
      return None
  
  def DFSIter(d, start, end):
    searched = []
    stack = []
    if start.data == end.data:
      searched.append(start)
      return searched
    else:
      start.isvisited = True
      stack.append(start)
      while(len(d)!=0)
        n = stack.pop()
        searched.append(n)
        if n.data == end.data:
          return searched
        if n in d:
          if !n.isvisited:
            stack.append(n)
            n.isvisited = True
        len(d)= len(d) - 1
    return None

  #work on
  def BFTRec(d, graph):
    searched = []
    que = []
    num = d.keys()
    for i in range(num)
      if i in d:
        if !d[i].isvisited:
          que.append(d[i])
          n = que.pop()
          searched.append(n)
          if n in d:
            if !n.isvisited:
              que.append(n)
              n.isvisited = True
              recurs = GraphSearch.DFSRec(d, graph)
    return recurs
 
  #work on
  def BFTIter(d, graph):
    searched = []
    que = []
    num = d.keys()
    for i in range(num):
      if i in d:
        while(len(que)!=0):
          if !d[i].isvisited:
            que.append(d[i])
            n = que.pop()
            searched.append(n)
            if n in d:
              if !n.isvisited:
                que.append(n)
                n.isvisited = True
    return searched
